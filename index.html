<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NEON TUNNEL</title>
  <link rel="stylesheet" href="/assets/css/style.css">
</head>
<body>

  <div id="mobile-controls" class="landscape">
    <div class="joystick">
      <div class="joystick-knob"></div>
    </div>
    <div class="action-btn">ðŸš€</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    console.log("=== Starting Neon Tunnel ===");
    
    // ======================================== MOBILE DETECTION & VIRTUAL KEYS ========================================
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      ('ontouchstart' in window);
    
    const virtualKeys = {
      w: false,
      s: false,
      a: false,
      d: false,
      arrowup: false,
      arrowdown: false,
      arrowleft: false,
      arrowright: false
    };
    
    // ======================================== THREE JS TUNNEL  ========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0015);
    scene.fog = new THREE.FogExp2(0x0a0015, 0.00075);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.domElement.id = 'three-canvas';
    document.body.appendChild(renderer.domElement);

    const points = [];
    const radius = 2000;
    const segments = 700;
    for (let i = 0; i <= segments; i++) {
      const angle = (i / segments) * Math.PI * 2;
      points.push(new THREE.Vector3(
        Math.cos(angle) * radius,
        0,                        
        Math.sin(angle) * radius
      ));
    }
    const curve = new THREE.CatmullRomCurve3(points, true);
    const tubeRadius = 210;
    const geometry = new THREE.TubeGeometry(curve, 120, tubeRadius, 12, true);

    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      wireframe: true,
      transparent: true,
      opacity: 0.4,
    });

    const tube = new THREE.Mesh(geometry, material);
    scene.add(tube);

    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.18,
      blending: THREE.AdditiveBlending,
    });
    const glowTube = new THREE.Mesh(geometry, glowMat);
    glowTube.scale.set(1.12, 1.12, 1.12);
    scene.add(glowTube);

    const shipOffset = { x: 0, y: 0 };
    const shipSpeed = 3.5;
    const maxOffset = { x: 400, y: 250 };
    const keys = {};

    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
    
    // DO A BARREL ROLL!
    function startBarrelRoll(direction = 1) {
      if (!isBarrelRolling) {
        isBarrelRolling = true;
        barrelRollProgress = 0;
        barrelRollDirection = direction;
        console.log("DO A BARREL ROLL!");
      }
    }
    
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !isBarrelRolling) {
        e.preventDefault();
        const direction = keys['a'] || keys['arrowleft'] ? -1 : 1;
        startBarrelRoll(direction);
      }
    });

    let time = 0;
    const speed = 220;
    const rollAmount = 0.95;

 // THREE JS
    function animateThree() {
      requestAnimationFrame(animateThree);
      time += 0.016;

      // SHIP MOVEMENT
      if (keys['w'] || keys['arrowup']) shipOffset.y += shipSpeed;
      if (keys['s'] || keys['arrowdown']) shipOffset.y -= shipSpeed;
      if (keys['a'] || keys['arrowleft']) shipOffset.x -= shipSpeed;
      if (keys['d'] || keys['arrowright']) shipOffset.x += shipSpeed;

      // MOVEMENT BOUNDARIES
      shipOffset.x = Math.max(-maxOffset.x, Math.min(maxOffset.x, shipOffset.x));
      shipOffset.y = Math.max(-maxOffset.y, Math.min(maxOffset.y, shipOffset.y));

      const progress = (time * speed) % 1;
      const pos = curve.getPointAt(progress);
      const tangent = curve.getTangentAt(progress);

      camera.position.copy(pos);
      const lookTarget = pos.clone().add(tangent);
      camera.lookAt(lookTarget);
      camera.up.set(0, 1, 0).applyAxisAngle(tangent, -Math.PI * rollAmount);

      const pulse = Math.sin(time * 1.8) * 0.5 + 0.5;
      material.color.setHSL(0.52 + pulse * 0.12, 1, 0.65);
      glowMat.color.copy(material.color);

      camera.position.y += Math.sin(time * 1.2) * 6;

      renderer.render(scene, camera);
    }
    
    console.log("Starting Three.js animation...");
    animateThree();

    // ======================================== CANVAS 2D LAYER -SHIP AND PARTICLES ========================================    
    console.log("Setting up 2D canvas layer...");
    const gameCanvas = document.createElement('canvas');
    gameCanvas.id = 'game-canvas';
    gameCanvas.width = innerWidth;
    gameCanvas.height = innerHeight;
    document.body.appendChild(gameCanvas);
    
    const ctx = gameCanvas.getContext('2d');
    const spaceshipImg = new Image();
    spaceshipImg.src = 'assets/images/spaceship.png';
    let spriteLoaded = false;
    let spriteWidth = 0;
    let frameWidth = 0;
    
    spaceshipImg.onload = () => {
      console.log("Spaceship sprite loaded!");
      spriteLoaded = true;
      spriteWidth = spaceshipImg.width;
      frameWidth = spriteWidth / 5; // TO ACCOUNT FOR ALL 5 FRAMES
    };
    
    spaceshipImg.onerror = () => {
      console.error("Failed to load spaceship sprite");
    };

    // SPACESHIP STATE
    const ship = {
      x: innerWidth / 2,
      y: innerHeight / 2,
      width: 170,
      height: 170,
      rotation: 0,
      currentFrame: 2, // 0=UP, 1=HALF-UP, 2=NEUTRAL, 3=HALF-DOWN, 4=DOWN
    };

    // PARTICLES!!!
    const particles = [];
    const maxParticles = 30;
    const particleSpawnRate = 3;

    class Particle {
      constructor(x, y) {
        this.x = x + (Math.random() - 0.5) * 20;
        this.y = y + (Math.random() - 0.5) * 20;
        this.vx = (Math.random() - 0.5) * 40;
        this.vy = 20 + Math.random() * 90;
        this.life = 0.5 + Math.random() * 0.15;
        this.maxLife = this.life;
        this.radius = 20;
        this.color = Math.random() > 0.5 ? '#00ffff' : '#8C92AC';
      }

      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
      }

      draw(ctx) {
        ctx.save();
        const opacity = Math.max(0, this.life / this.maxLife);
        ctx.globalAlpha = opacity * 0.3;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      isDead() {
        return this.life <= 0 || this.y > innerHeight + 50;
      }
    }

    let targetRotation = 0;
    let currentRotation = 0;
    
    let targetFrame = 2; 
    let currentFrameFloat = 2.0; 
    
    // BARREL ROLL!!!
    let isBarrelRolling = false;
    let barrelRollProgress = 0;
    let barrelRollDirection = 1; 
    const barrelRollDuration = 0.6; 

    let lastTime = performance.now();
    
    function animateCanvas() {
      requestAnimationFrame(animateCanvas);
      
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      
      // BARREL ROLL SCREEN FLASH!
      if (isBarrelRolling) {
        const flashIntensity = Math.sin(barrelRollProgress * Math.PI) * 0.15;
        ctx.fillStyle = `rgba(0, 255, 255, ${flashIntensity})`;
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      }
      
      const movingUp = keys['w'] || keys['arrowup'] || virtualKeys['w'] || virtualKeys['arrowup'];
      const movingDown = keys['s'] || keys['arrowdown'] || virtualKeys['s'] || virtualKeys['arrowdown'];
      const movingLeft = keys['a'] || keys['arrowleft'] || virtualKeys['a'] || virtualKeys['arrowleft'];
      const movingRight = keys['d'] || keys['arrowright'] || virtualKeys['d'] || virtualKeys['arrowright'];

      ship.x = innerWidth / 2 + shipOffset.x;
      ship.y = innerHeight / 2 - shipOffset.y; 

      // SMOOTH FRAME TRANSITIONS with MOMENTUM
      let desiredFrame = 2;
      
      if (movingUp) {
        desiredFrame = 0;
      } else if (movingDown) {
        desiredFrame = 4; 
      }
      
      let interpolationSpeed;
      if (movingUp || movingDown) {
        interpolationSpeed = 0.25;
        targetFrame = desiredFrame;
      } else {
        interpolationSpeed = 0.08;
        targetFrame = 2;
      }
      
      currentFrameFloat += (targetFrame - currentFrameFloat) * interpolationSpeed;
      
      ship.currentFrame = Math.round(currentFrameFloat);

      if (isBarrelRolling) {
        barrelRollProgress += dt / barrelRollDuration;
        
        if (barrelRollProgress >= 1.0) {
          isBarrelRolling = false;
          barrelRollProgress = 0;
          currentRotation = 0;
        } else {
          const rollAngle = barrelRollProgress * 360 * barrelRollDirection;
          ship.rotation = rollAngle * Math.PI / 180;
          
          if (particles.length < maxParticles * 2) {
            for (let i = 0; i < 2; i++) {
              particles.push(new Particle(ship.x, ship.y));
            }
          }
        }
      } else {
        targetRotation = 0;
        if (movingLeft) targetRotation = -20;
        if (movingRight) targetRotation = 20;
        currentRotation += (targetRotation - currentRotation) * 0.15;
        ship.rotation = currentRotation * Math.PI / 180;
      }

      ctx.globalAlpha = 1;
      if (spriteLoaded) {
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.rotation);
      
        const sx = ship.currentFrame * frameWidth;
        const sy = 0;
        const sw = frameWidth;
        const sh = spaceshipImg.height;
        
        ctx.drawImage(
          spaceshipImg,
          sx, sy, sw, sh,
          -ship.width / 2, -ship.height / 2, ship.width, ship.height
        );
        
        ctx.restore();
      } else {
        // LOADING PLACEHOLDER
        ctx.fillStyle = '#0ff';
        ctx.fillRect(ship.x - 20, ship.y - 20, 40, 40);
      }

      ctx.globalAlpha = 0.2;

      // PARTICLES!!! 
      for (let i = 0; i < particleSpawnRate; i++) {
        if (particles.length < maxParticles) {
          particles.push(new Particle(ship.x, ship.y));
        }
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        particles[i].draw(ctx);
        
        if (particles[i].isDead()) {
          particles.splice(i, 1);
        }
      }


    }

    console.log("Starting 2D canvas animation...");
    animateCanvas();
    
    // ======================================== MOBILE CONTROLS ========================================
    const mobileControls = document.getElementById('mobile-controls');
    const joystick = document.querySelector('.joystick');
    const joystickKnob = document.querySelector('.joystick-knob');
    const actionBtn = document.querySelector('.action-btn');
    const keyboardHint = document.getElementById('keyboard-hint');
    
    function showMobileControls() {
      if (mobileControls && isMobile) {
        mobileControls.style.display = 'flex';
        if (keyboardHint) keyboardHint.style.display = 'none';
      }
    }
    
    function hideMobileControls() {
      if (mobileControls) {
        mobileControls.style.display = 'none';
        if (keyboardHint) keyboardHint.style.display = 'block';
      }
    }
    
    if (isMobile) {
      showMobileControls();
    }
    
    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    const joystickRadius = 60;
    const deadZone = 15;
    
    function updateJoystick(touch) {
      if (!joystickActive) return;
      
      const rect = joystick.getBoundingClientRect();
      joystickCenter.x = rect.left + rect.width / 2;
      joystickCenter.y = rect.top + rect.height / 2;
      
      const deltaX = touch.clientX - joystickCenter.x;
      const deltaY = touch.clientY - joystickCenter.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      const clampedDistance = Math.min(distance, joystickRadius);
      const angle = Math.atan2(deltaY, deltaX);
      
      const knobX = Math.cos(angle) * clampedDistance;
      const knobY = Math.sin(angle) * clampedDistance;
      
      joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
      
      if (Math.abs(deltaX) > deadZone) {
        virtualKeys['a'] = deltaX < 0;
        virtualKeys['arrowleft'] = deltaX < 0;
        virtualKeys['d'] = deltaX > 0;
        virtualKeys['arrowright'] = deltaX > 0;
      } else {
        virtualKeys['a'] = false;
        virtualKeys['arrowleft'] = false;
        virtualKeys['d'] = false;
        virtualKeys['arrowright'] = false;
      }
      
      if (Math.abs(deltaY) > deadZone) {
        virtualKeys['w'] = deltaY < 0;
        virtualKeys['arrowup'] = deltaY < 0;
        virtualKeys['s'] = deltaY > 0;
        virtualKeys['arrowdown'] = deltaY > 0;
      } else {
        virtualKeys['w'] = false;
        virtualKeys['arrowup'] = false;
        virtualKeys['s'] = false;
        virtualKeys['arrowdown'] = false;
      }
    }
    
    function resetJoystick() {
      joystickActive = false;
      joystick.classList.remove('active');
      joystickKnob.style.transform = 'translate(-50%, -50%)';
      virtualKeys['a'] = false;
      virtualKeys['arrowleft'] = false;
      virtualKeys['d'] = false;
      virtualKeys['arrowright'] = false;
      virtualKeys['w'] = false;
      virtualKeys['arrowup'] = false;
      virtualKeys['s'] = false;
      virtualKeys['arrowdown'] = false;
    }
    
    if (joystick) {
      joystick.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystickActive = true;
        joystick.classList.add('active');
        updateJoystick(e.touches[0]);
      });
      
      joystick.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updateJoystick(e.touches[0]);
      });
      
      joystick.addEventListener('touchend', (e) => {
        e.preventDefault();
        resetJoystick();
      });
      
      joystick.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        resetJoystick();
      });
    }
    
    if (actionBtn) {
      actionBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        actionBtn.style.transform = 'scale(0.9)';
        // DO A BARREL ROLL!
        const direction = (virtualKeys['a'] || virtualKeys['arrowleft']) ? -1 : 1;
        startBarrelRoll(direction);
      });
      
      actionBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        actionBtn.style.transform = 'scale(1)';
      });
      
      actionBtn.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        actionBtn.style.transform = 'scale(1)';
      });
    }
    
    window.addEventListener('keydown', (e) => { // TOGGLE MOBILE CONTROLS WITH M
      if (e.key === 'm' || e.key === 'M') {
        if (mobileControls.style.display === 'flex') {
          hideMobileControls();
        } else {
          showMobileControls();
        }
      }
    });
    
    window.addEventListener('resize', () => {
      const w = innerWidth;
      const h = innerHeight;
      
      // THREE JS
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      
      // 2D CANVAS / SPACE SHIP
      gameCanvas.width = w;
      gameCanvas.height = h;
    });

    console.log("=== Setup complete! ===");
  </script>
</body>
</html>